import "dart:io";

import "package:flutter/material.dart";
import "package:synaps_flutter/synaps_flutter.dart";
import "package:muon/controllers/muonnote.dart";
import "package:muon/controllers/muonproject.dart";
import 'package:muon/logic/helpers.dart';
import "package:muon/serializable/muon.dart";
import "package:muon/logic/musicxml.dart";
import "package:flutter_audio_desktop/flutter_audio_desktop.dart";

part "muonvoice.g.dart";

@Controller()
class MuonVoiceController with WeakEqualityController {
  MuonProjectController project;

  /// Folder name of the voice model this voice uses
  @Observable()
  String modelName = MuonHelpers.getDefaultVoiceModel();

  /// Randomise timings of this vocal on each render (for use as a backing
  /// vocal for harmonies)
  /// 
  /// TODO: actually use this value
  @Observable()
  bool randomiseTiming = false;

  /// The list of all of the notes that this voice sings
  @Observable()
  List<MuonNoteController> notes = [];

  /// Exports this voice to a MusicXML class
  MusicXML exportVoiceToMusicXML() {
    return project.exportVoiceToMusicXML(this);
  }

  /// Sorts all of the notes in this voice chronologically
  void sortNotesByTime() {
    notes.sort((a,b) => a.startAtTime.compareTo(b.startAtTime));
  }

  /// Helper method to add a note into this voice, and also updates the
  /// note's reference to this voice
  void addNote(MuonNoteController note) {
    note.voice = this;
    notes.add(note);
  }

  /// Internal list of voice colors
  static final noteColors = [
    Colors.blue,
    Colors.purple,
    Colors.amber,
    Colors.indigo,
    Colors.green,
    Colors.teal,
    Colors.brown,
  ];

  /// The UI color of this voice
  get color {
    final voiceID = (project != null ? project.voices.indexOf(this) : -1) + 1;
    return noteColors[voiceID % noteColors.length];
  }

  /// The base filename to use for files generated by this voice
  String get voiceFileName => project.projectFileNameNoExt + "_" + project.voices.indexOf(this).toString() + "_voice";

  /// Creates Neutrino-compatible labels for this voice by first exporting
  /// to a MusicXML file, and then running `musicXMLtoLabel.exe`
  Future<void> makeLabels() async {
    final musicXML = exportVoiceToMusicXML();
    final musicXMLString = MusicXMLUtils.serializeMusicXML(musicXML);

    if(!Directory(project.getProjectFilePath("musicxml/")).existsSync()) {
      Directory(project.getProjectFilePath("musicxml/")).createSync();
    }

    if(!Directory(project.getProjectFilePath("label/")).existsSync()) {
      Directory(project.getProjectFilePath("label/")).createSync();
    }

    if(!Directory(project.getProjectFilePath("label/full/")).existsSync()) {
      Directory(project.getProjectFilePath("label/full/")).createSync();
    }

    if(!Directory(project.getProjectFilePath("label/mono/")).existsSync()) {
      Directory(project.getProjectFilePath("label/mono/")).createSync();
    }

    final musicXMLPath = project.getProjectFilePath("musicxml/" + voiceFileName + ".musicxml");

    File(musicXMLPath)
      .writeAsStringSync(musicXMLString);

    await Process.run(MuonHelpers.getProgramPath("musicXMLtoLabel"), [
      musicXMLPath,
      project.getProjectFilePath("label/full/" + voiceFileName + ".lab"),
      project.getProjectFilePath("label/mono/" + voiceFileName + ".lab"),
      "-x",
      MuonHelpers.getRawProgramPath("settings/dic"),
    ]).then((ProcessResult results) {
      print(results.stdout);
    });
  }

  /// Generates mgc/bap/f0 files by executing Neutrino
  /// Requires labels to be already generated, and currently does
  /// not check whether labels already exist!
  /// 
  /// TODO: check if labels exist
  Future<void> runNeutrino() async {
    if(!Directory(project.getProjectFilePath("neutrino/")).existsSync()) {
      Directory(project.getProjectFilePath("neutrino/")).createSync();
    }

    if(!Directory(project.getProjectFilePath("label/timing/")).existsSync()) {
      Directory(project.getProjectFilePath("label/timing/")).createSync();
    }

    await Process.run(MuonHelpers.getProgramPath("NEUTRINO"), [
      project.getProjectFilePath("label/full/" + voiceFileName + ".lab"),
      project.getProjectFilePath("label/timing/" + voiceFileName + ".lab"),
      project.getProjectFilePath("neutrino/" + voiceFileName + ".f0"),
      project.getProjectFilePath("neutrino/" + voiceFileName + ".mgc"),
      project.getProjectFilePath("neutrino/" + voiceFileName + ".bap"),
      MuonHelpers.getRawProgramPath("model/" + modelName + "/"),
      "-n","8",
      "-k","0",
      "-m",
      "-t",
    ]).then((ProcessResult results) {
      print(results.stdout);
    });
  }

  /// Generates an audio file using the WORLD vocoder
  /// Requires mgc/bap/f0, and does not verify whether these have
  /// already been generated!
  /// 
  /// WORLD is a faster vocoder but at the cost of quality
  /// 
  /// TODO: check if mgc/bap/f0 exists
  Future<void> vocodeWORLD() async {
    if(!Directory(project.getProjectFilePath("audio/")).existsSync()) {
      Directory(project.getProjectFilePath("audio/")).createSync();
    }

    await Process.run(MuonHelpers.getProgramPath("WORLD"), [
      project.getProjectFilePath("neutrino/" + voiceFileName + ".f0"),
      project.getProjectFilePath("neutrino/" + voiceFileName + ".mgc"),
      project.getProjectFilePath("neutrino/" + voiceFileName + ".bap"),
      "-f","1.0",
      "-m","1.0",
      "-o",project.getProjectFilePath("audio/" + voiceFileName + "_world.wav"),
      "-n","8",
      "-t",
    ]).then((ProcessResult results) {
      print(results.stdout);
    });
  }

  /// Generates an audio file using the NSF vocoder
  /// Requires mgc/bap/f0, and does not verify whether these have
  /// already been generated!
  /// 
  /// NSF is a better quality vocoder but at the cost of speed
  /// and requires a NVIDIA GPU
  /// 
  /// TODO: check if mgc/bap/f0 exists
  Future<void> vocodeNSF() async {
    if(!Directory(project.getProjectFilePath("audio/")).existsSync()) {
      Directory(project.getProjectFilePath("audio/")).createSync();
    }

    await Process.run(MuonHelpers.getProgramPath("NSF_IO"), [
      project.getProjectFilePath("label/full/" + voiceFileName + ".lab"),
      project.getProjectFilePath("label/timing/" + voiceFileName + ".lab"),
      project.getProjectFilePath("neutrino/" + voiceFileName + ".f0"),
      project.getProjectFilePath("neutrino/" + voiceFileName + ".mgc"),
      project.getProjectFilePath("neutrino/" + voiceFileName + ".bap"),
      modelName,
      project.getProjectFilePath("audio/" + voiceFileName + "_nsf.wav"),
      "-t",
    ],workingDirectory: MuonHelpers.getRawProgramPath("")).then((ProcessResult results) {
      print(results.stdout);
    });
  }

  AudioPlayer audioPlayer;
  int audioPlayerDuration = 0;
  Future<AudioPlayer> getAudioPlayer([Duration playPos]) async {
    final voiceID = project.voices.indexOf(this);
    if(audioPlayer == null) {
      audioPlayer = new AudioPlayer(id: voiceID);
    }

    await audioPlayer.unload();
    final suc = await audioPlayer.load(project.getProjectFilePath("audio/" + voiceFileName + "_world.wav"));

    audioPlayerDuration = (await audioPlayer.getDuration()).inMilliseconds;
    audioPlayer.setPosition(playPos ?? Duration(seconds: 2));

    if(!suc) {
      audioPlayer = null;
    }

    return audioPlayer;
  }

  MuonVoice toSerializable([MuonProject project]) {
    final out = MuonVoice();
    out.project = project ?? this.project.toSerializable();
    out.modelName = this.modelName;
    out.randomiseTiming = this.randomiseTiming;
    for(final note in notes) {
      out.notes.add(note.toSerializable());
    }
    return out;
  }

  static MuonVoiceController fromSerializable(MuonVoice obj, [MuonProjectController project]) {
    final out = MuonVoiceController().ctx();
    out.project = project ?? MuonProjectController.fromSerializable(obj.project);
    out.modelName = obj.modelName;
    out.randomiseTiming = obj.randomiseTiming;
    for(final note in obj.notes) {
      out.addNote(MuonNoteController.fromSerializable(note));
    }
    return out;
  }
}
